---
title: "Praktikum 07"
name: "Füge deinen Namen hizu"
date: "Füge ein Datum hinzu"
output: 
  html_document: 
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

# Ich habe hier erneut Standardeinstellungen für Code-chunks angepasst
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

```

# Lade Packages

1. Lade `dplyr` und `palmerpenguins` Packages
2. Führe den Code-chunk aus

```{r}

library(dplyr)
library(palmerpenguins)

```
# Tastaturkürzel

Ich habe hier nochmals die wichtigsten Tastaturkürzel für dich hinzugefügt

- **Einen neuen Code-chunk hinzufügen:** Ctrl + Alt + I
- **Code "Zeile für Zeile" innerhalb eines Code-chunks ausführen:** Ctrl + Enter
- **Den gesamten Code-chunk ausführen:** Ctrl + Shift + Enter
- **Die Pipe (%>%):** Ctrl + Shift + M
- **Der Zuweisungs-Operator (<-)**: Alt + -


# dplyr::summarise()

Mit der Funktion `summarise()` wird ein neuer Dataframe erstellt. Der Dataframe enthält eine Spalte für jede angegebene zusammenfassende Statistik.

Dieser enthält eine (oder mehrere) Zeilen für jede Kombination von Gruppierungsvariablen.

```{r dplyr-summarise}

penguins %>% 
  summarise()

penguins %>% 
  summarise(n())

penguins %>% 
  summarise(
    count = n(),
    max = max(year)
  )

nrow(penguins)
dim(penguins)
str(penguins)
glimpse(penguins)

```


```{r dplyr-summarise-filter}

penguins %>% 
  filter(species == "Chinstrap", island == "Dream") %>% 
  summarise(anzahl = n())

```

# dplyr::group_by()

Die Funktion `group_by()` wird genutzt um einen existierenden Dataframe in einen gruppierten Dataframe zu konvertieren, sodass die folgenden Anweisungen auf der Ebene der Gruppen angewandt werden. Der resultierende Dataframe enthält eine (oder mehrere) Zeilend für jede Kombination von Gruppierungsvariablen, und eine Spalte für jede Gruppierungsvariable.

```{r dplyr-summarise-group} 

penguins %>% 
  group_by(species, island) 

penguins %>% 
  group_by(island, species) %>% 
  summarise(count = n())

penguins %>% 
  filter(body_mass_g > 3700) %>% 
  group_by(island, species) %>% 
  summarise(count = n())

```


```{r dplyr-summarise-group-na}

penguins %>% 
  group_by(island) %>% 
  summarise(
    count = n(),
    mean = mean(bill_depth_mm)
  )

penguins %>% 
  group_by(island) %>% 
  summarise(
    count = n(),
    mean = mean(bill_depth_mm, na.rm = TRUE)
  )

penguins %>% 
  filter(!is.na(bill_depth_mm)) %>% 
  group_by(island) %>% 
  summarise(
    count = n(),
    mean = mean(bill_depth_mm)
  )


## drop_na

library(tidyr)

penguins %>% 
  drop_na()

penguins %>% 
  drop_na(bill_depth_mm)

penguins %>% 
  drop_na(!sex)


```

```{r dplyr-summarise-fkt}

penguins %>%
  drop_na(!sex) %>% 
  group_by(island, sex) %>%
  summarise(
    count = n(),
    mass_mean = mean(body_mass_g),
    mass_sd = sd(body_mass_g),
    mass_min = min(body_mass_g),
    mass_max = max(body_mass_g),
    mass_median = median(body_mass_g)
  )


```


```{r dplyr-summarise-plot}

library(ggplot2)

penguins %>% 
  drop_na(sex) %>%  
  ggplot(aes(x = island, y = bill_depth_mm, color = island)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.3) +
  coord_flip() +
  facet_wrap(~sex, ncol = 1) +
  scale_color_brewer(type = "qual", palette = 1) +
  theme_minimal(base_size = 16)

```

Mehr zu `across()`:

- https://dplyr.tidyverse.org/reference/across.html
- https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/



# dplyr::count()

Mit der Funktion `count()` lassen sich Häufigkeitstabellen erstellen. Die Funktion kombiniert die Funktionen `group_by` und `summarise()` mit `n()` in eine Funktion.

```{r dplyr-count}

penguins %>% 
  group_by(species) %>% 
  summarise(
    n = n()
  )

penguins %>% 
  count(species)

penguins %>% 
  count(species, island) %>% 
  count(species, wt = n)


```

# dplyr::case_when()

Die Funktion `case_when()` in Kombination mit `mutate()` erlaubt es neue Variablen basierend auf bestimmten Konditionen anderer Variablen zu erstellen.

```{r, dplyr-case-when}

penguins %>% 
  mutate(size_bin = case_when(
    body_mass_g > 4500 ~ "large",
    body_mass_g > 3000 & body_mass_g <= 4500 ~ "medium",
    body_mass_g <= 3000 ~ "small")) %>%
  count(size_bin)


penguins %>% 
  mutate(flipper_rank = case_when(
    flipper_length_mm < 200 ~ 1,
    flipper_length_mm >= 200 ~ 2,
    TRUE ~ 0)) %>%
  count(flipper_rank)

```


# dplyr::across() - Zusatzmaterial

Die Funktion `across()` besonders nützlich im Zusammenhang mit `summarise()`. Sie wird genutzt um zusammengefasste Dataframes für mehrere Variablen mittels einer Helfer Funktion zu erstellen.

```{r dplyr-across}

penguins %>% 
  summarise(across(ends_with("mm"), mean, na.rm = TRUE))

```

Andere Helfer Funktionen:

- `starts_with()`
- `contains()`

```{r dplyr-across}

penguins %>% 
  group_by(species) %>% 
  summarise(across(.cols = contains("mm"),
                   list(avg = mean),
                   na.rm = TRUE,
                   .names = "{.fn}_{.col}"))

penguins %>%
  group_by(species) %>% 
  summarise(across(.cols = contains("mm"),
                   .fns = ~mean(.x, na.rm = TRUE), # Ein Weg die Funktion zu schreiben
                   .names = "mean_{.col}")) # Ein Namenskürzel für alle neuen Spalten

penguins %>% 
  group_by(species) %>% 
  summarise(across(.cols = starts_with("bill"),
                   .fns = max, # Ein weiterer Weg. na.rm = TRUE ist hier ausserhalb
                   na.rm = TRUE,
                   .names = "max_{.col}"))  # Ein Namenskürzel für alle neuen Spalten

penguins %>%
  group_by(species) %>%
  summarize(across(contains("length"),
                  .fns = list(avg = mean, sd = sd), # Eine Liste mit Funktionen und zugehörigen Namen
                   na.rm = TRUE,
                   .names = "{.fn}_{.col}"))

```

```{r dplyr-if-any-na}

# behalte nur Beobachtungen bei welcher in keiner Spalte NA enthalten ist
penguins %>% 
  drop_na()

# behalte nur Boabachtungen bei welchen in mindestens einer Spalte NA auftaucht 
penguins %>% 
  filter(if_any(.cols = everything(), .fns = is.na))

```
